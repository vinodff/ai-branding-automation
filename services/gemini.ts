
import { GeneratedBrandName, SentimentResult, BrandContext, RoadmapStep } from "../types";
import { BrandCraftAPI } from "./api_client";

export class GeminiService {
  async generateBrandNames(context: BrandContext | null): Promise<GeneratedBrandName[]> {
    try {
      const result = await BrandCraftAPI.generateNames({
        context_id: context?.id,
        industry_override: context?.industry,
        vibe: context?.tone
      });
      
      // The backend returns { provider: 'gemini', response: '...' }
      // We assume the response text is a JSON string of names
      if (result.response) {
        try {
          return JSON.parse(result.response);
        } catch {
          // Fallback parsing if it's not strictly JSON
          return [];
        }
      }
      return [];
    } catch (error) {
      console.error("Name generation failed:", error);
      return [];
    }
  }

  async generateLogo(userPrompt: string, context: BrandContext | null): Promise<string> {
    const result = await BrandCraftAPI.generateLogo({
      prompt: userPrompt,
      context_id: context?.id
    });
    
    if (result.image_url) {
      return `http://localhost:8000${result.image_url}`;
    }
    throw new Error("No image generated by provider");
  }

  async generateContent(type: 'tagline' | 'mission' | 'social', context: BrandContext | null): Promise<string> {
    const result = await BrandCraftAPI.generateContent({
      type,
      context_id: context?.id
    });
    return result.response || "No content generated.";
  }

  async analyzeSentiment(text: string): Promise<SentimentResult> {
    const result = await BrandCraftAPI.analyzeSentiment(text);
    
    // Transform backend HF response to UI SentimentResult
    return {
      sentiment: result.label === 'positive' ? 'positive' : result.label === 'negative' ? 'negative' : 'neutral',
      score: Math.round(result.confidence * 100),
      breakdown: {
        trust: Math.round(result.confidence * 100),
        excitement: result.label === 'positive' ? 85 : 30,
        reliability: result.label === 'positive' ? 90 : 40
      },
      summary: `The content exhibits a ${result.label} sentiment with ${Math.round(result.confidence * 100)}% confidence.`
    };
  }

  async researchIndustry(context: BrandContext | null) {
    // This still uses direct search grounding or a specialized backend route
    // For now, mapping to a generic content/research route if available
    const result = await BrandCraftAPI.generateContent({
      type: 'research',
      context_id: context?.id
    });
    return {
      text: result.response || "No research data available.",
      sources: []
    };
  }

  async generateRoadmap(context: BrandContext | null): Promise<RoadmapStep[]> {
    const result = await BrandCraftAPI.generateContent({
      type: 'roadmap',
      context_id: context?.id
    });
    
    try {
      return JSON.parse(result.response);
    } catch {
      return [];
    }
  }

  async chat(history: any[], message: string, context: BrandContext | null) {
    const result = await BrandCraftAPI.assistantChat(message, history, context?.id);
    return result.response;
  }
}
